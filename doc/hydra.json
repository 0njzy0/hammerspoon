{"name": "api", "doc": "The Hydra namespace.", "subitems": [{"name": "alert", "def": "api.alert(str, seconds = 2)", "doc": "Shows a message in large words briefly in the middle of the screen."},{"name": "call", "def": "api.call(fn, ...) -> ...", "doc": "Just like pcall, except that failures are handled using api.errorhandler"},{"name": "check_accessibility", "def": "api.check_accessibility(shouldprompt) -> isenabled", "doc": "Returns whether accessibility is enabled. If passed `true`, promtps the user to enable it."},{"name": "douserfile", "def": "api.douserfile(name)", "doc": "Convenience wrapper around dofile() and api.userfile(name)"},{"name": "errorhandler", "def": "api.errorhandler = function(err)", "doc": "Error handler for api.call; intended for you to set, not for third party libs"},{"name": "fileexists", "def": "api.fileexists(path) -> exists, isdir", "doc": "Checks if a file exists, and whether it's a directory."},{"name": "focushydra", "def": "api.focushydra()", "doc": "Makes Hydra the currently focused app; useful in combination with textgrids."},{"name": "jsondocs", "def": "api.jsondocs() -> string", "doc": "Returns the documentation as a JSON string for you to generate pretty docs with. The top-level is a group. Groups have keys: name (string), doc (string), subitems (list of items), subgroups (list of groups); Items have keys: name (string), def (string), doc (string)."},{"name": "reload", "def": "api.reload()", "doc": "Reloads your init-file. Makes sure to clear any state that makes sense to clear (hotkeys, pathwatchers, etc)."},{"name": "resourcesdir", "def": "api.resourcesdir -> string", "doc": "The location of the built-in lua source files."},{"name": "showabout", "def": "api.showabout()", "doc": "Displays the standard OS X about panel; implicitly focuses Hydra."},{"name": "userfile", "def": "api.userfile(name)", "doc": "Returns the full path to the file ~/.hydra/{name}.lua"},{"name": "uuid", "def": "api.uuid() -> string", "doc": "Returns a UUID as a string"}], "subgroups": [{"name": "app", "doc": "Manipulate running applications.", "subitems": [{"name": "appforpid", "def": "api.app.appforpid(pid) -> app or nil", "doc": "Returns the running app for the given pid, if it exists."},{"name": "appsforbundleid", "def": "api.app.appsforbundleid(bundleid) -> app[]", "doc": "Returns any running apps that have the given bundleid."},{"name": "launchorfocus", "def": "api.app.launchorfocus(name)", "doc": "Launches the app with the given name, or activates it if it's already running."},{"name": "runningapps", "def": "api.app.runningapps() -> app[]", "doc": "Returns all running apps."},{"name": "activate", "def": "api.app:activate() -> bool", "doc": "Tries to activate the app (make it focused) and returns its success."},{"name": "allwindows", "def": "api.app:allwindows() -> window[]", "doc": "Returns all open windows owned by the given app."},{"name": "bundleid", "def": "api.app:bundleid() -> string", "doc": "Returns the bundle identifier of the app."},{"name": "hide", "def": "api.app:hide()", "doc": "Hides the app (and all its windows)."},{"name": "ishidden", "def": "api.app:ishidden() -> bool", "doc": "Returns whether the app is currently hidden."},{"name": "kill", "def": "api.app:kill()", "doc": "Tries to terminate the app."},{"name": "kill9", "def": "api.app:kill9()", "doc": "Assuredly terminates the app."},{"name": "show", "def": "api.app:show()", "doc": "Unhides the app (and all its windows) if it's hidden. Yeah, this method name should probably be renamed."},{"name": "title", "def": "api.app:title() -> string", "doc": "Returns the localized name of the app (in UTF8)."},{"name": "visiblewindows", "def": "api.app:visiblewindows() -> win[]", "doc": "Returns only the app's windows that are visible."}], "subgroups": []},{"name": "autolaunch", "doc": "Functions for controlling whether Hydra launches at login.", "subitems": [{"name": "get", "def": "api.autolaunch.get() -> bool", "doc": "Returns whether Hydra launches when you login."},{"name": "set", "def": "api.autolaunch.set(bool)", "doc": "Sets whether Hydra launches when you login."}], "subgroups": []},{"name": "ext", "doc": "Standard high-level namespace for third-party extensions.", "subitems": [], "subgroups": []},{"name": "fn", "doc": "Super-helpful functional programming utilities.", "subitems": [{"name": "concat", "def": "api.fn.concat(t1, t2)", "doc": "Adds all elements of t2 to the end of t1."},{"name": "contains", "def": "api.fn.contains(t, el) -> bool", "doc": "Returns whether a table contains a given element."},{"name": "filter", "def": "api.fn.filter(t, fn) -> t", "doc": "Returns a table of the elements in t in which t(el) is truthy."},{"name": "indexof", "def": "api.fn.indexof(t, el) -> int or nil", "doc": "Returns the index of a given element in a table, or nil if not found."},{"name": "map", "def": "api.fn.map(t, fn) -> t", "doc": "Returns a table of the results of t(el) on every el in t."},{"name": "mapcat", "def": "api.fn.mapcat(t, fn) -> t2", "doc": "Runs fn(el) for every el in t, and assuming the results are tables, combines them into a new table."},{"name": "reduce", "def": "api.fn.reduce(t, fn) -> t2", "doc": "Runs fn(el1, el2) for every el in t, then fn(result, el3), etc, until there's only one left."}], "subgroups": []},{"name": "geometry", "doc": "Mathy stuff.", "subitems": [{"name": "hypot", "def": "api.geometry.hypot(point) -> number", "doc": "Returns hypotenuse of a line defined from 0,0 to point."},{"name": "intersectionrect", "def": "api.geometry.intersectionrect(rect1, rect2) -> rect3", "doc": "Returns the intersection of two rects as a new rect."},{"name": "point", "def": "api.geometry.point(x, y) -> point", "doc": "Convenience function for creating a point-table."},{"name": "rect", "def": "api.geometry.rect(x, y, w, y) -> rect", "doc": "Convenience function for creating a rect-table."},{"name": "rectmidpoint", "def": "api.geometry.rectmidpoint(r) -> point", "doc": "Returns the midpoint of a rect."},{"name": "rotateccw", "def": "api.geometry.rotateccw(point, aroundpoint, ntimes = 1) -> point", "doc": "Rotates a point around another point N times."},{"name": "size", "def": "api.geometry.size(w, h) -> size", "doc": "Convenience function for creating a size-table."}], "subgroups": []},{"name": "hotkey", "doc": "Manage global hotkeys.", "subitems": [{"name": "bind", "def": "api.hotkey.bind(...) -> hotkey", "doc": "Shortcut for: return api.hotkey.new(...):enable()"},{"name": "disableall", "def": "api.hotkey.disableall()", "doc": "Disables all hotkeys; automatically called when user config reloads."},{"name": "new", "def": "api.hotkey.new(mods, key, fn) -> hotkey", "doc": "Creates a new hotkey that can be enabled. Mods is a table containing any of the elements {cmd, ctrl, alt, shift}. Key may be any 1-character string, or 'F1', 'Enter', etc. Both are case-insensitive. The hotkey has the public fields: key, mods, fn."},{"name": "disable", "def": "api.hotkey:disable() -> self", "doc": "Disables the given hotkey; does not remove it from api.hotkey.keys."},{"name": "enable", "def": "api.hotkey:enable() -> hotkey", "doc": "Registers the hotkey's fn as the callback when the user presses key while holding mods."}], "subgroups": []},{"name": "log", "doc": "Functionality to assist with debugging and experimentation.", "subitems": [{"name": "addhandler", "def": "api.log.addhandler(fn(str)) -> index", "doc": "Registers a function to handle new log lines."},{"name": "lines", "def": "api.log.lines = {}", "doc": "List of lines logged so far; caps at api.log.maxlines. You may clear it by setting it to {} yourself."},{"name": "maxlines", "def": "api.log.maxlines = 500", "doc": "Maximum number of lines to be logged."},{"name": "removehandler", "def": "api.log.removehandler(index)", "doc": "Unregisters a function that handles new log lines."},{"name": "show", "def": "api.log.show() -> textgrid", "doc": "Opens a textgrid that can browse all logs."}], "subgroups": []},{"name": "menu", "doc": "Control Hydra's menu-bar icon.", "subitems": [{"name": "hide", "def": "api.menu.hide()", "doc": "Hides Hydra's menubar icon."},{"name": "show", "def": "api.menu.show(fn() -> itemstable)", "doc": "Shows Hyra's menubar icon. The function should return a table of tables with keys: title, fn, checked (optional), disabled (optional)"}], "subgroups": []},{"name": "mouse", "doc": "Functions for manipulating the mouse cursor.", "subitems": [{"name": "get", "def": "api.mouse.get() -> point", "doc": "Returns the current location of the mouse on the current screen as a point."},{"name": "set", "def": "api.mouse.set(point)", "doc": "Moves the mouse to the given location on the current screen."}], "subgroups": []},{"name": "notify", "doc": "Apple's built-in notifications system.", "subitems": [{"name": "register", "def": "api.notify.register(tag, fn()) -> id", "doc": "Registers a function to be called when an Apple notification with the given tag is clicked."},{"name": "show", "def": "api.notify.show(title, subtitle, text, tag)", "doc": "Show an Apple notification. Tag is a unique string that identifies this notification, and will be passed to api.notify.clicked() if the notification is clicked. None of the strings are optional, though they may each be blank."},{"name": "unregister", "def": "api.notify.unregister(id)", "doc": "Unregisters a function to no longer be called when an Apple notification with the given tag is clicked."},{"name": "unregisterall", "def": "api.notify.unregisterall()", "doc": "Unregisters all functions registered for notification-clicks; called automatically when user config reloads."}], "subgroups": []},{"name": "pathwatcher", "doc": "Watch paths recursively for changes.", "subitems": [{"name": "new", "def": "api.pathwatcher.new(path, fn())", "doc": "Returns a new pathwatcher that can be started and stopped. Contains fields: path, fn."},{"name": "stopall", "def": "api.pathwatcher.stopall()", "doc": "Calls p:stop() for all started pathwatchers; called automatically when user config reloads."},{"name": "start", "def": "api.pathwatcher:start()", "doc": "Registers pathwatcher's fn as a callback when pathwatcher's path or any descendent changes."},{"name": "stop", "def": "api.pathwatcher:stop()", "doc": "Unregisters pathwatcher's fn so it won't be called again until the pathwatcher is restarted."}], "subgroups": []},{"name": "repl", "doc": "Read-Eval-Print-Loop", "subitems": [{"name": "open", "def": "api.repl.open() -> textgrid", "doc": "Opens a (primitive) REPL that has full access to Hydra's API"}], "subgroups": []},{"name": "screen", "doc": "Manipulate monitors (aka screens).", "subitems": [{"name": "allscreens", "def": "api.screen.allscreens() -> screen[]", "doc": "Returns all the screens there are."},{"name": "frame", "def": "api.screen.frame(screen) -> rect", "doc": "Returns a screen's frame in its own coordinate space."},{"name": "mainscreen", "def": "api.screen.mainscreen() -> screen", "doc": "Returns the 'main' screen, i.e. the one containing the currently focused window."},{"name": "settint", "def": "api.screen.settint(redarray, greenarray, bluearray)", "doc": "Set the tint on a screen; experimental."},{"name": "vislbleframe", "def": "api.screen.visibleframe(screen) -> rect", "doc": "Returns a screen's frame in its own coordinate space, without the dock or menu."},{"name": "frame_including_dock_and_menu", "def": "api.screen:frame_including_dock_and_menu() -> rect", "doc": "Returns the screen's rect in absolute coordinates, including the dock and menu."},{"name": "frame_without_dock_or_menu", "def": "api.screen:frame_without_dock_or_menu() -> rect", "doc": "Returns the screen's rect in absolute coordinates, without the dock or menu."},{"name": "next", "def": "api.screen:next() -> screen", "doc": "Returns the screen 'after' this one; I have no idea how they're ordered though."},{"name": "previous", "def": "api.screen:previous() -> screen", "doc": "Returns the screen 'before' this one; I have no idea how they're ordered though."}], "subgroups": []},{"name": "textgrid", "doc": "Super easy in-Hydra GUI windows.", "subitems": [{"name": "closeall", "def": "api.textgrid.closeall()", "doc": "Closes all non-protected textgrids; called automatically when user config is reloaded."},{"name": "open", "def": "api.textgrid.open() -> textgrid", "doc": "Opens a new textgrid window."},{"name": "textgrids", "def": "api.textgrid.textgrids = {}", "doc": "All currently open textgrid windows; do not mutate this at all."},{"name": "clear", "def": "api.textgrid:clear(bg)", "doc": "Clears the textgrid and sets its background color to bg, a CSS-like string."},{"name": "close", "def": "api.textgrid:close()", "doc": "Closes the given textgrid window."},{"name": "closed", "def": "api.textgrid:closed = function()", "doc": "Calls the given function when the textgrid is closed. Defaults to nil."},{"name": "focus", "def": "api.textgrid:focus()", "doc": "Brings the textgrid to front and focuses it; implicitly focuses Hydra."},{"name": "getfont", "def": "api.textgrid:getfont() -> name, pointsize", "doc": "Gets the name and pointsize currently used in the textgrid."},{"name": "getsize", "def": "api.textgrid:getsize() -> size", "doc": "Returns the size (nubmer of rows and columns) as a size-table with keys {x,y}."},{"name": "keydown", "def": "api.textgrid:keydown = function(t)", "doc": "Calls the given function when a key is pressed in the focused textgrid. The table t contains keys {ctrl, alt, cmd, key}. Defaults to nil."},{"name": "protect", "def": "api.textgrid:protect()", "doc": "Prevents the textgrid from closing when your config is reloaded."},{"name": "resize", "def": "api.textgrid:resize(size)", "doc": "Resizes the textgrid to the number of rows and columns given in the size-table with keys {x,y}."},{"name": "resized", "def": "api.textgrid:resized = function()", "doc": "Calls the given function when the textgrid is resized. Defaults to nil."},{"name": "set", "def": "api.textgrid:set(char, x, y, fg, bg)", "doc": "Sets the given character in the given position, where char is a UTF8 character thingy, x and y are grid spaces, fg and bg are CSS-like strings."},{"name": "settitle", "def": "api.textgrid:settitle(title)", "doc": "Changes the title of the textgrid window."},{"name": "usefont", "def": "api.textgrid:usefont(name, pointsize)", "doc": "Sets the new font of the textgrid, potentially changing its visible size (no resize event is fired)."},{"name": "window", "def": "api.textgrid:window() -> window", "doc": "Returns the api.window that represents this textgrid."}], "subgroups": []},{"name": "timer", "doc": "Execute functions with various timing rules.", "subitems": [{"name": "days", "def": "api.timer.days(n) -> sec", "doc": "Returns the number of days in seconds."},{"name": "doafter", "def": "api.timer.doafter(sec, fn())", "doc": "Runs the function after sec seconds."},{"name": "hours", "def": "api.timer.hours(n) -> sec", "doc": "Returns the number of hours in seconds."},{"name": "minutes", "def": "api.timer.minutes(n) -> sec", "doc": "Returns the number of minutes in seconds."},{"name": "new", "def": "api.timer.new(seconds, fn) -> timer", "doc": "Creates a new timer that can be started. Has the fields: seconds, fn."},{"name": "runonce", "def": "api.timer.runonce(fn())", "doc": "Runs the function exactly once in the entire lifespan of Hydra; reset only when you quit/restart."},{"name": "seconds", "def": "api.timer.seconds(n) -> sec", "doc": "Returns the number of seconds in seconds."},{"name": "stopall", "def": "api.timer.stopall()", "doc": "Stops all running timers; called automatically when user config reloads."},{"name": "weeks", "def": "api.timer.weeks(n) -> sec", "doc": "Returns the number of weeks in seconds."},{"name": "start", "def": "api.timer:start() -> timer", "doc": "Begins to execute timer.fn every timer.seconds; calling this does not cause an initial firing of the timer immediately."},{"name": "stop", "def": "api.timer:stop() -> timer", "doc": "Stops the timer's fn from getting called until started again."}], "subgroups": []},{"name": "updates", "doc": "Check for and install Hydra updates.", "subitems": [{"name": "available", "def": "api.updates.available = function(isavailable)", "doc": "Called after api.updates.check() runs, with a boolean parameter specifying whether an update is available. Default implementation pushes a notification when an update is available with the tag 'showupdate'."},{"name": "check", "def": "api.updates.check()", "doc": "Checks for an update. If one is available, calls api.updates.available(true); otherwise calls api.updates.available(false)."}], "subgroups": []},{"name": "webview", "doc": "For showing stuff in web views!", "subitems": [{"name": "clicked", "def": "api.webview.clicked = function(str)", "doc": "When a link is clicked with a URL like 'hydra:foo', this function is called (if set) with 'foo' as its argument."},{"name": "closed", "def": "api.webview.closed = function()", "doc": "Called (if set) when the webview closes."},{"name": "open", "def": "api.webview.open()", "doc": "Opens and returns a new webview instance; as with all other Hydra objects, it's just a table, and you're free to set whatever keys you want on it."},{"name": "loadfile", "def": "api.webview:loadfile(path)", "doc": "Loads the given file in the web view."},{"name": "loadstring", "def": "api.webview:loadstring(string, basepath)", "doc": "Loads the given string in the webview; basepath must be an absolute path."},{"name": "loadurl", "def": "api.webview:loadurl(url)", "doc": "Loads the given URL in the webview."},{"name": "setborderless", "def": "api.webview:setborderless(bool)", "doc": "Set whether a webview window has a border."},{"name": "sethasshadow", "def": "api.webview:sethasshadow(bool)", "doc": "Set whether a webview window has a shadow."},{"name": "setignoresmouse", "def": "api.webview:setignoresmouse(bool)", "doc": "Set whether a webview window can be interacted with via the mouse."},{"name": "settitle", "def": "api.webview:settitle(string)", "doc": "Set the title of a webview window."},{"name": "window", "def": "api.webview:window() -> window", "doc": "Return the api.window that represents the given webview."}], "subgroups": []},{"name": "window", "doc": "Functions for managing any window", "subitems": [{"name": "allwindows", "def": "api.window.allwindows() -> win[]", "doc": "Returns all windows"},{"name": "focusedwindow", "def": "api.window.focusedwindow() -> window", "doc": "Returns the focused window, or nil."},{"name": "visible_windows_sorted_by_recency", "def": "api.window.visible_windows_sorted_by_recency() -> win[]", "doc": "Experimental."},{"name": "visiblewindows", "def": "api.window.visiblewindows() -> win[]", "doc": "Get all windows on all screens that match api.window.isvisible."},{"name": "app", "def": "api.window:app() -> app", "doc": "Returns the app that the window belongs to."},{"name": "becomemain", "def": "api.window:becomemain() -> bool", "doc": "Make this window the main window of the given application; deos not implicitly focus the app."},{"name": "focus", "def": "api.window:focus() -> bool", "doc": "Try to make this window focused."},{"name": "focuswindow_east", "def": "api.window:focuswindow_east()", "doc": "Focus the first focus-able window to the east of this one."},{"name": "focuswindow_north", "def": "api.window:focuswindow_north()", "doc": "Focus the first focus-able window to the north of this one."},{"name": "focuswindow_south", "def": "api.window:focuswindow_south()", "doc": "Focus the first focus-able window to the south of this one."},{"name": "focuswindow_west", "def": "api.window:focuswindow_west()", "doc": "Focus the first focus-able window to the west of this one."},{"name": "frame", "def": "api.window:frame() -> rect", "doc": "Get the frame of the window in absolute coordinates."},{"name": "isminimized", "def": "api.window:isminimized() -> bool", "doc": "True if the window is currently minimized in the dock."},{"name": "isstandard", "def": "api.window:isstandard() -> bool", "doc": "True if the window's subrole indicates it's 'a standard window'."},{"name": "isvisible", "def": "api.window:isvisible() -> bool", "doc": "True if the app is not hidden, not minimized, and is a standard window"},{"name": "maximize", "def": "api.window:maximize()", "doc": "Make this window fill the whole screen its on, without covering the dock or menu."},{"name": "minimize", "def": "api.window:minimize()", "doc": "Minimizes the window."},{"name": "otherwindows_allscreens", "def": "api.window:otherwindows_allscreens() -> win[]", "doc": "Get every window except this one."},{"name": "otherwindows_samescreen", "def": "api.window:otherwindows_samescreen() -> win[]", "doc": "Get other windows on the same screen as self."},{"name": "role", "def": "api.window:role() -> string", "doc": "Returns the role of the window, whatever that means."},{"name": "screen", "def": "api.window:screen()", "doc": "Get the screen this window is mostly on."},{"name": "setframe", "def": "api.window:setframe(rect)", "doc": "Set the frame of the window in absolute coordinates."},{"name": "setsize", "def": "api.window:setsize(size)", "doc": "Resizes the window."},{"name": "settopleft", "def": "api.window:settopleft(point)", "doc": "Moves the window to the given point in absolute coordinate."},{"name": "size", "def": "api.window:size() -> size", "doc": "The size of the window."},{"name": "subrole", "def": "api.window:subrole() -> string", "doc": "Returns the subrole of the window, whatever that means."},{"name": "title", "def": "api.window:title() -> string", "doc": "Returns the title of the window (as UTF8)."},{"name": "topleft", "def": "api.window:topleft() -> point", "doc": "The top-left corner of the window in absolute coordinates."},{"name": "unminimize", "def": "api.window:unminimize()", "doc": "Un-minimizes the window."},{"name": "windows_to_east", "def": "api.window:windows_to_east()", "doc": "Get all windows east of this one, ordered by closeness."},{"name": "windows_to_north", "def": "api.window:windows_to_north()", "doc": "Get all windows north of this one, ordered by closeness."},{"name": "windows_to_south", "def": "api.window:windows_to_south()", "doc": "Get all windows south of this one, ordered by closeness."},{"name": "windows_to_west", "def": "api.window:windows_to_west()", "doc": "Get all windows west of this one, ordered by closeness."}], "subgroups": []}]}
